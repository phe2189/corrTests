% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/corrBoundsST.R
\name{corrBoundsST}
\alias{corrBoundsST}
\title{Rejection Boundaries Of 2+ Correlated Tests for Time-To-Event Endpoints at a Single Time}
\usage{
corrBoundsST(
  alpha = 0.025,
  w = c(1/4, 1/4, 1/2),
  eps = c(NA, NA, NA),
  corr = diag(3)
)
}
\arguments{
\item{alpha}{Overall one-sided type I error for the correlated hypothesis tests. Default 0.025.}

\item{w}{Weights for alpha allocation for the correlated tests.
The sum of w must be 1.}

\item{eps}{A vector of efficiency factors for testing all correlated hypotheses.
eps is required when method = "Customized Allocation". Must have at least one
component as NA. For example, eps = c(1, 1, NA) means allocating all gained
efficiency to H3. eps = c(NA, NA, NA) means equally allocating the gained
efficiency in all tests. For all j, eps\link{j} >= 1.}

\item{corr}{Correlation matrix for the correlated tests.}
}
\value{
A data frame including variables
\itemize{
\item p0 Rejection boundary in P without consideration of correlation
\item z0 Rejection boundary in Z without consideration of correlation
\item p  Rejection boundary in P with consideration of correlation
\item z  Rejection boundary in Z with consideration of correlation
\item eps  Efficiency factor
\item max.eps   Maximum possible efficiency factor for each test
}
@references
}
\description{
This function calculates the rejection boundary in p value
(significance level) and z value for each of multiple correlated logrank test.
The computation is based on mvtnorm R package.
}
\examples{
#Example 2. Two subgroups and overall population.
corr = matrix(1, nrow=3, ncol=3)
corr[1, 2] = corr[2, 1] = corrZ(e.strat = list(AandB1=120, AnotB1=100, AandB2=120, BnotA2=80),
   e.unstr = list(A1=220, B2=200, minAorB=300),                 
   r.strat = list(AandB = 1/2, AnotB=1/2, BnotA=1/2),
   r.unstr = list(A=1/2, B=1/2, AandB=1/2), pAandB.unstr = 0.5,
   strat = c("Y"), method = c("Observed"))
   
corr[1, 3] = corr[3, 1] = corrZ(e.strat = list(AandB1=220, AnotB1=0, AandB2=220, BnotA2=280),
   e.unstr = list(A1=220, B2=500, minAorB=500),                 
   r.strat = list(AandB = 1/2, AnotB=1/2, BnotA=1/2),
   r.unstr = list(A=1/2, B=1/2, AandB=1/2), pAandB.unstr = 0.5,
   strat = c("Y"), method = c("Observed"))    
corr[2, 3] = corr[3, 2] = corrZ(e.strat = list(AandB1=200, AnotB1=0, AandB2=200, BnotA2=300),
   e.unstr = list(A1=200, B2=500, minAorB=500),                 
   r.strat = list(AandB = 1/2, AnotB=1/2, BnotA=1/2),
   r.unstr = list(A=1/2, B=1/2, AandB=1/2), pAandB.unstr = 0.5,
   strat = c("Y"), method = c("Observed"))    
   
#Strategy 1: equal allocation of efficiency to all tests 
corrBoundsST(alpha = 0.025, w = c(1/4, 1/4, 1/2), eps = c(NA,NA,NA), corr=corr)

#Strategy 2: equal allocation of efficiency to H1 and H2, no efficiency to H3 
corrBoundsST(alpha = 0.025, w = c(1/4, 1/4, 1/2), eps = c(NA,NA,1), corr=corr)

#Strategy 3: maximize power to H3 
corrBoundsST(alpha = 0.025, w = c(1/4, 1/4, 1/2), eps = c(1,1,NA), corr=corr)

#Strategy 4: maximize power to H1 
corrBoundsST(alpha = 0.025, w = c(1/4, 1/4, 1/2), eps = c(NA,1,1), corr=corr)
   
#Strategy 5: maximize power to H2 
corrBoundsST(alpha = 0.025, w = c(1/4, 1/4, 1/2), eps = c(1,NA,1), corr=corr)
   
}
